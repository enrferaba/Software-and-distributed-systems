[
    {
        "id": "d1f2a3b4c5d6e7f8",
        "type": "tab",
        "label": "Core Telemetry",
        "disabled": false,
        "info": "Grade 10 ingestion, validation, storage, alerts"
    },
    {
        "id": "e1f2a3b4c5d6e7f9",
        "type": "tab",
        "label": "Ops & Observability",
        "disabled": false,
        "info": "Grade 10 operations, metrics, CSV, backups"
    },
    {
        "id": "a1b2c3d4e5f67890",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "RG-05 Rain",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "once": true,
        "onceDelay": "0.7",
        "topic": "",
        "payloadType": "date",
        "x": 120,
        "y": 40,
        "wires": [
            [
                "b1c2d3e4f5a67890"
            ]
        ]
    },
    {
        "id": "b1c2d3e4f5a67890",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Build Rain Reading",
        "func": "const state = context.get('state') || {phase:Math.PI/2};\\nstate.phase = (state.phase + Math.PI/40) % (Math.PI*2);\\nconst base = Math.max(0, 5 + Math.sin(state.phase)*5 + (Math.random()-0.5)*2);\\nconst readingId = `RG-05-rain-${Date.now()}-${Math.floor(Math.random()*1000)}`;\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    site_id: \\\"RG-05\\\",\\n    district: \\\"macarena\\\",\\n    metric: \\\"rain\\\",\\n    value: Number(base.toFixed(2)),\\n    unit: \\\"mm\\\",\\n    quality: \\\"synthetic\\\",\\n    source: \\\"sim.rain\\\",\\n    reading_id: readingId,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \\\"1.0.0\\\"\\n};\\nmsg.topic = \\\"sewer.macarena.RG-05.rain\\\";\\nmsg.is_probe = false;\\ncontext.set('state', state);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 40,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "a2b3c4d5e6f78901",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "MH-12 Level",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "once": true,
        "onceDelay": "0.5",
        "topic": "",
        "payloadType": "date",
        "x": 120,
        "y": 80,
        "wires": [
            [
                "b2c3d4e5f6a78901"
            ]
        ]
    },
    {
        "id": "b2c3d4e5f6a78901",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Build Level Reading",
        "func": "const state = context.get('state') || {phase:0};\\nstate.phase = (state.phase + Math.PI/20) % (Math.PI*2);\\nconst noise = (Math.random()-0.5)*0.02;\\nconst base = 1.6 + Math.sin(state.phase)*0.45 + noise;\\nconst readingId = `MH-12-level-${Date.now()}-${Math.floor(Math.random()*1000)}`;\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    site_id: \\\"MH-12\\\",\\n    district: \\\"triana\\\",\\n    metric: \\\"level\\\",\\n    value: Number(base.toFixed(3)),\\n    unit: \\\"m\\\",\\n    quality: \\\"synthetic\\\",\\n    source: \\\"sim.level\\\",\\n    reading_id: readingId,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \\\"1.0.0\\\"\\n};\\nmsg.topic = \\\"sewer.triana.MH-12.level\\\";\\nmsg.is_probe = false;\\ncontext.set('state', state);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 80,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "a3b4c5d6e7f89012",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "MH-12 Flow",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "once": true,
        "onceDelay": "0.6",
        "topic": "",
        "payloadType": "date",
        "x": 120,
        "y": 120,
        "wires": [
            [
                "b3c4d5e6f7a89012"
            ]
        ]
    },
    {
        "id": "b3c4d5e6f7a89012",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Build Flow Reading",
        "func": "const state = context.get('state') || {phase:Math.PI/4};\\nstate.phase = (state.phase + Math.PI/18) % (Math.PI*2);\\nconst noise = (Math.random()-0.5)*5;\\nconst base = 120 + Math.sin(state.phase)*80 + noise;\\nconst readingId = `MH-12-flow-${Date.now()}-${Math.floor(Math.random()*1000)}`;\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    site_id: \\\"MH-12\\\",\\n    district: \\\"triana\\\",\\n    metric: \\\"flow\\\",\\n    value: Number(Math.max(0, base).toFixed(2)),\\n    unit: \\\"lps\\\",\\n    quality: \\\"synthetic\\\",\\n    source: \\\"sim.flow\\\",\\n    reading_id: readingId,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \\\"1.0.0\\\"\\n};\\nmsg.topic = \\\"sewer.triana.MH-12.flow\\\";\\nmsg.is_probe = false;\\ncontext.set('state', state);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 120,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "a4b5c6d7e8f90123",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "MH-21 Pressure",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "once": true,
        "onceDelay": "0.8",
        "topic": "",
        "payloadType": "date",
        "x": 120,
        "y": 160,
        "wires": [
            [
                "b4c5d6e7f8a90123"
            ]
        ]
    },
    {
        "id": "b4c5d6e7f8a90123",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Build Pressure Reading",
        "func": "const state = context.get('state') || {phase:Math.PI/3};\\nstate.phase = (state.phase + Math.PI/22) % (Math.PI*2);\\nconst base = 1 + Math.sin(state.phase)*0.3 + (Math.random()-0.5)*0.05;\\nconst readingId = `MH-21-pressure-${Date.now()}-${Math.floor(Math.random()*1000)}`;\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    site_id: \\\"MH-21\\\",\\n    district: \\\"nervion\\\",\\n    metric: \\\"pressure\\\",\\n    value: Number(base.toFixed(3)),\\n    unit: \\\"bar\\\",\\n    quality: \\\"synthetic\\\",\\n    source: \\\"sim.pressure\\\",\\n    reading_id: readingId,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \\\"1.0.0\\\"\\n};\\nmsg.topic = \\\"sewer.nervion.MH-21.pressure\\\";\\nmsg.is_probe = false;\\ncontext.set('state', state);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 200,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "a5b6c7d8e9f01234",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "E2E Probe",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "10",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "payloadType": "date",
        "x": 110,
        "y": 240,
        "wires": [
            [
                "b5c6d7e8f9a01234"
            ]
        ]
    },
    {
        "id": "b5c6d7e8f9a01234",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Build Probe",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst readingId = crypto.randomBytes(8).toString('hex');\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    site_id: \\\"probe\\\",\\n    district: \\\"monitoring\\\",\\n    metric: \\\"latency\\\",\\n    value: 0,\\n    unit: \\\"ms\\\",\\n    quality: \\\"probe\\\",\\n    source: \\\"probe\\\",\\n    reading_id: readingId,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \\\"1.0.0\\\"\\n};\\nmsg.topic = \\\"sewer.monitoring.probe.latency\\\";\\nmsg.is_probe = true;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 350,
        "y": 240,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "df1f04d4e5f6a90f",
        "type": "link in",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "CSV Import Input",
        "links": [
            "8899aabbccddeeff"
        ],
        "x": 520,
        "y": 20,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "c1d2e3f4a5b6c7d8",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Enrich Trace & Lamport",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst lamport = flow.get('lamport') || 1;\\nconst nextLamport = lamport + 1;\\nflow.set('lamport', nextLamport);\\nconst traceId = msg.payload.trace_id || crypto.randomBytes(16).toString('hex');\\nconst spanId = crypto.randomBytes(8).toString('hex');\\nmsg.payload.trace_id = traceId;\\nmsg.payload.span_id = spanId;\\nmsg.payload.lamport = nextLamport;\\nmsg.headers = msg.headers || {};\\nmsg.headers.trace_id = traceId;\\nmsg.headers.span_id = spanId;\\nmsg.headers.lamport = nextLamport;\\nif(!msg.payload.reading_id){\\n    msg.payload.reading_id = crypto.createHash('sha1').update(`${msg.payload.site_id}|${msg.payload.metric}|${msg.payload.ts_iso8601}|${msg.payload.value}`).digest('hex');\\n}\\nconst startTimes = flow.get('e2e_start') || {};\\nstartTimes[traceId] = Date.now();\\nflow.set('e2e_start', startTimes);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 640,
        "y": 120,
        "wires": [
            [
                "c2d3e4f5a6b7c8d9"
            ]
        ]
    },
    {
        "id": "c2d3e4f5a6b7c8d9",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Producer Dedupe",
        "func": "const cache = flow.get('producerSeen') || {};\\nconst now = Date.now();\\nconst ttl = 5 * 60 * 1000;\\nfor (const key in cache) {\\n    if(now - cache[key] > ttl){\\n        delete cache[key];\\n    }\\n}\\nconst key = msg.payload.reading_id;\\nif(cache[key]){\\n    return null;\\n}\\ncache[key] = now;\\nflow.set('producerSeen', cache);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 120,
        "wires": [
            [
                "c3d4e5f6a7b8c9da"
            ]
        ]
    },
    {
        "id": "c3d4e5f6a7b8c9da",
        "type": "json",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "JSON Encode",
        "property": "payload",
        "action": "str",
        "pretty": false,
        "x": 1090,
        "y": 120,
        "wires": [
            [
                "c4d5e6f7a8b9cadb"
            ]
        ]
    },
    {
        "id": "c4d5e6f7a8b9cadb",
        "type": "mqtt out",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "MQTT Telemetry",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "cfg_mqtt",
        "x": 1310,
        "y": 120,
        "wires": []
    },
    {
        "id": "d1e2f3a4b5c6d7e8",
        "type": "mqtt in",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "MQTT Ingest",
        "topic": "sewer/#",
        "qos": "1",
        "datatype": "auto",
        "broker": "cfg_mqtt",
        "nl": false,
        "rap": false,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 280,
        "wires": [
            [
                "d2e3f4a5b6c7d8e9"
            ]
        ]
    },
    {
        "id": "d2e3f4a5b6c7d8e9",
        "type": "json",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "JSON Decode",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 340,
        "y": 280,
        "wires": [
            [
                "d3e4f5a6b7c8d9ea"
            ]
        ]
    },
    {
        "id": "d3e4f5a6b7c8d9ea",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Validate Ingress",
        "func": "const required = [\\\"ts_iso8601\\\",\\\"site_id\\\",\\\"district\\\",\\\"metric\\\",\\\"value\\\",\\\"unit\\\",\\\"quality\\\",\\\"source\\\",\\\"reading_id\\\"];\\nconst missing = required.filter(k => msg.payload[k] === undefined || msg.payload[k] === null || msg.payload[k] === \\\"\\\");\\nif(missing.length){\\n    msg.error_category = \\\"schema\\\";\\n    msg.error_detail = {missing};\\n    return [null,msg];\\n}\\nconst ts = Date.parse(msg.payload.ts_iso8601);\\nif(isNaN(ts)){\\n    msg.error_category = \\\"timestamp\\\";\\n    msg.error_detail = {ts: msg.payload.ts_iso8601};\\n    return [null,msg];\\n}\\nconst now = Date.now();\\nif(Math.abs(now - ts) > 5 * 60 * 1000){\\n    msg.error_category = \\\"ts_skew\\\";\\n    msg.error_detail = {delta_ms: now - ts};\\n    return [null,msg];\\n}\\nif(typeof msg.payload.value !== \\\"number\\\"){\\n    msg.payload.value = Number(msg.payload.value);\\n    if(Number.isNaN(msg.payload.value)){\\n        msg.error_category = \\\"value\\\";\\n        msg.error_detail = {raw: msg.payload.value};\\n        return [null,msg];\\n    }\\n}\\nreturn [msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 280,
        "wires": [
            [
                "d5e6f7a8b9cadbec"
            ],
            [
                "d4e5f6a7b8c9daeb"
            ]
        ]
    },
    {
        "id": "d5e6f7a8b9cadbec",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Quality Gate",
        "func": "const limits = {\\n    \\\"level\\\": {min:0, max:4},\\n    \\\"flow\\\": {min:0, max:500},\\n    \\\"rain\\\": {min:0, max:200},\\n    \\\"pressure\\\": {min:0, max:2}\\n};\\nconst metric = msg.payload.metric;\\nconst limit = limits[metric] || {min:-Infinity, max:Infinity};\\nlet quality = \\\"good\\\";\\nif(msg.payload.value < limit.min || msg.payload.value > limit.max){\\n    quality = \\\"suspect\\\";\\n}\\nmsg.payload.quality = quality;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 260,
        "wires": [
            [
                "d6e7f8a9bacbdced"
            ]
        ]
    },
    {
        "id": "d6e7f8a9bacbdced",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Ingress Dedupe",
        "func": "const cache = global.get('ingestSeen') || {};\\nconst now = Date.now();\\nconst ttl = 24 * 60 * 60 * 1000;\\nfor (const key in cache){\\n    if(now - cache[key] > ttl){\\n        delete cache[key];\\n    }\\n}\\nconst key = msg.payload.reading_id;\\nif(cache[key]){\\n    return null;\\n}\\ncache[key] = now;\\nglobal.set('ingestSeen', cache);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 260,
        "wires": [
            [
                "d7e8f9a0bbccdd0e"
            ]
        ]
    },
    {
        "id": "d7e8f9a0bbccdd0e",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Track Ingest Metrics",
        "func": "const stats = global.get('stats') || {};\\nstats.ingest = (stats.ingest || 0) + 1;\\nstats.queueDepth = (stats.queueDepth || 0) + 1;\\nstats.lastIngestTs = Date.now();\\nglobal.set('stats', stats);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 260,
        "wires": [
            [
                "d8e9f0a1bccdde0f"
            ]
        ]
    },
    {
        "id": "d8e9f0a1bccdde0f",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Route AMQP",
        "func": "msg.exchange = \\\"sewer.telemetry\\\";\\nmsg.routingKey = `${msg.payload.district}.${msg.payload.site_id}.${msg.payload.metric}`;\\nmsg.properties = {\\n    contentType: \\\"application/json\\\",\\n    deliveryMode: 2,\\n    headers: {\\n        trace_id: msg.payload.trace_id,\\n        span_id: msg.payload.span_id,\\n        lamport: msg.payload.lamport,\\n        schema_ver: msg.payload.schema_ver\\n    }\\n};\\nconst readiness = global.get('readiness') || {};\\nreadiness.amqp = true;\\nglobal.set('readiness', readiness);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 240,
        "wires": [
            [
                "d9e0f1a2bdceef10",
                "f9a0bbccd0e1f2a6"
            ]
        ]
    },
    {
        "id": "d9e0f1a2bdceef10",
        "type": "amqp out",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Rabbit Publish",
        "amqp": "cfg_amqp",
        "routingKey": "",
        "exchange": "",
        "durable": true,
        "persistent": true,
        "deliveryMode": "2",
        "payloadType": "json",
        "x": 1660,
        "y": 220,
        "wires": []
    },
    {
        "id": "d4e5f6a7b8c9daeb",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "DLQ Envelope",
        "func": "msg.exchange = \"sewer.telemetry.dlq\";\\nmsg.routingKey = msg.error_category || \"unknown\";\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    original: msg.payload,\\n    error: msg.error_detail,\\n    category: msg.error_category\\n};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 340,
        "wires": [
            [
                "e0f1a2b3c4d5e6f7"
            ]
        ]
    },
    {
        "id": "e0f1a2b3c4d5e6f7",
        "type": "amqp out",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Rabbit DLQ",
        "amqp": "cfg_amqp",
        "routingKey": "",
        "exchange": "",
        "durable": true,
        "persistent": true,
        "deliveryMode": "2",
        "payloadType": "json",
        "x": 1070,
        "y": 340,
        "wires": []
    },
    {
        "id": "e2f3a4b5c6d7e8f1",
        "type": "catch",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Pipeline Errors",
        "scope": null,
        "uncaught": false,
        "x": 140,
        "y": 360,
        "wires": [
            [
                "e1f2a3b4c5d6e7f0"
            ]
        ]
    },
    {
        "id": "e1f2a3b4c5d6e7f0",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Catch Formatter",
        "func": "msg.error_category = \"runtime\";\\nmsg.error_detail = {message: msg.error && msg.error.message, source: msg.error && msg.error.source && msg.error.source.id};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 360,
        "wires": [
            [
                "d4e5f6a7b8c9daeb"
            ]
        ]
    },
    {
        "id": "bf1d02d2e3f4a90d",
        "type": "catch",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "AMQP Error",
        "scope": [
            "d9e0f1a2bdceef10",
            "e0f1a2b3c4d5e6f7",
            "e5f6a7b8c9d0e1f4"
        ],
        "uncaught": false,
        "x": 1180,
        "y": 300,
        "wires": [
            [
                "cf1e03d3e4f5a90e"
            ]
        ]
    },
    {
        "id": "cf1e03d3e4f5a90e",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Mark AMQP Down",
        "func": "const readiness = global.get('readiness') || {postgres:true,influx:true,amqp:true};\\nreadiness.amqp = false;\\nglobal.set('readiness', readiness);\\nmsg.error_category = \"amqp\";\\nmsg.error_detail = {message: msg.error && msg.error.message};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 300,
        "wires": [
            [
                "d4e5f6a7b8c9daeb"
            ]
        ]
    },
    {
        "id": "e5f6a7b8c9d0e1f4",
        "type": "amqp in",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Telemetry Consumer",
        "amqp": "cfg_amqp",
        "queue": "telemetry.main",
        "autoAck": false,
        "ack": "manual",
        "prefetch": "50",
        "x": 140,
        "y": 480,
        "wires": [
            [
                "e6f7a8b9cad0e1f5"
            ]
        ]
    },
    {
        "id": "e6f7a8b9cad0e1f5",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Backoff & Retry",
        "func": "msg.attempt = msg.attempt || 0;\\nif(msg.properties && msg.properties.headers && msg.properties.headers['x-attempt']){\\n    msg.attempt = msg.properties.headers['x-attempt'];\\n}\\nmsg.attempt++;\\nmsg.properties = msg.properties || {};\\nmsg.properties.headers = msg.properties.headers || {};\\nmsg.properties.headers['x-attempt'] = msg.attempt;\\nlet backoff = 0;\\nif(msg.attempt > 1){\\n    const raw = 200 * Math.pow(2, msg.attempt - 2);\\n    const clipped = Math.min(30000, raw);\\n    const jitter = clipped * (Math.random() - 0.5);\\n    backoff = Math.max(0, Math.round(clipped + jitter));\\n}\\nmsg.backoff_ms = backoff;\\nmsg.delay = backoff;\\nif(msg.attempt > 5){\\n    const dlq = JSON.parse(JSON.stringify(msg));\\n    dlq.exchange = \"sewer.telemetry.dlq\";\\n    dlq.routingKey = \"exhausted\";\\n    dlq.payload = {reason: \"max_attempts\", original: msg.payload};\\n    const ackMsg = {ack: true, fields: msg.fields};\\n    return [null, dlq, ackMsg];\\n}\\nreturn [msg,null,null];",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 480,
        "wires": [
            [
                "e7f8a9bacbd0e1f6"
            ],
            [
                "e0f1a2b3c4d5e6f7"
            ],
            [
                "fb0cbdd0e1f2a678"
            ]
        ]
    },
    {
        "id": "e7f8a9bacbd0e1f6",
        "type": "delay",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Backoff Delay",
        "pauseType": "delayv",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "outputs": 1,
        "x": 600,
        "y": 460,
        "wires": [
            [
                "e8f9a0bbccd0e1f7"
            ]
        ]
    },
    {
        "id": "e8f9a0bbccd0e1f7",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Dispatch Storage & Analytics",
        "func": "const payload = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\\nconst ackInfo = msg.fields || (msg.amqp && msg.amqp.fields) || {};\\nconst template = {payload, headers: msg.headers, properties: msg.properties, amqp: {fields: ackInfo}};\\nconst copy1 = JSON.parse(JSON.stringify(template));\\nconst copy2 = JSON.parse(JSON.stringify(template));\\nconst copy3 = JSON.parse(JSON.stringify(template));\\nconst copy4 = JSON.parse(JSON.stringify(template));\\nconst stats = global.get('stats') || {};\\nstats.queueDepth = Math.max(0, (stats.queueDepth || 0) - 1);\\nstats.lastConsumeTs = Date.now();\\nglobal.set('stats', stats);\\nreturn [copy1, copy2, copy3, copy4];",
        "outputs": 4,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 460,
        "wires": [
            [
                "e9f0a1bccdd0e1f8"
            ],
            [
                "f1a2b3c4d5e6f7a8"
            ],
            [
                "f3a4b5c6d7e8f9a0"
            ],
            [
                "fa0bbccd0e1f2a67"
            ]
        ]
    },
    {
        "id": "e9f0a1bccdd0e1f8",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Format Postgres Upsert",
        "func": "const p = msg.payload;\\nmsg.query = \"INSERT INTO readings (ts_iso8601, site_id, district, metric, value, unit, quality, source, reading_id, trace_id, span_id, lamport) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12) ON CONFLICT (reading_id) DO UPDATE SET value=EXCLUDED.value, quality=EXCLUDED.quality, ts_iso8601=EXCLUDED.ts_iso8601, lamport=EXCLUDED.lamport\";\\nmsg.params = [p.ts_iso8601,p.site_id,p.district,p.metric,p.value,p.unit,p.quality,p.source,p.reading_id,p.trace_id,p.span_id,p.lamport];\\nconst readiness = global.get('readiness') || {};\\nreadiness.postgres = true;\\nglobal.set('readiness', readiness);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 420,
        "wires": [
            [
                "f0a1b2c3d4e5f6a7"
            ]
        ]
    },
    {
        "id": "f0a1b2c3d4e5f6a7",
        "type": "postgres",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Timescale Writer",
        "postgre": "cfg_postgres",
        "outputs": 0,
        "x": 1400,
        "y": 420,
        "wires": []
    },
    {
        "id": "e3f4a5b6c7d8e9f2",
        "type": "catch",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Postgres Error",
        "scope": [
            "f0a1b2c3d4e5f6a7"
        ],
        "uncaught": false,
        "x": 1180,
        "y": 380,
        "wires": [
            [
                "e4f5a6b7c8d9e0f3"
            ]
        ]
    },
    {
        "id": "e4f5a6b7c8d9e0f3",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Mark Postgres Down",
        "func": "const readiness = global.get('readiness') || {postgres:true,influx:true,amqp:true};\\nreadiness.postgres = false;\\nglobal.set('readiness', readiness);\\nmsg.error_category = \"postgres\";\\nmsg.error_detail = {message: msg.error && msg.error.message};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 380,
        "wires": [
            [
                "d4e5f6a7b8c9daeb"
            ]
        ]
    },
    {
        "id": "f1a2b3c4d5e6f7a8",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Format Influx Point",
        "func": "const p = msg.payload;\\nmsg.measurement = \"reading\";\\nmsg.payload = [{\\n    measurement: \"reading\",\\n    tags: {site: p.site_id, district: p.district, metric: p.metric, unit: p.unit, quality: p.quality},\\n    fields: {value: p.value, source: p.source, lamport: p.lamport},\\n    timestamp: new Date(p.ts_iso8601).getTime()\\n}];\\nconst readiness = global.get('readiness') || {};\\nreadiness.influx = true;\\nglobal.set('readiness', readiness);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 480,
        "wires": [
            [
                "f2a3b4c5d6e7f8a9"
            ]
        ]
    },
    {
        "id": "f2a3b4c5d6e7f8a9",
        "type": "influxdb out",
        "z": "d1f2a3b4c5d6e7f8",
        "influxdb": "cfg_influx",
        "name": "Influx Writer",
        "measurement": "reading",
        "precision": "",
        "retentionPolicy": "",
        "x": 1400,
        "y": 480,
        "wires": []
    },
    {
        "id": "fe0fc0d0e1f2a90b",
        "type": "catch",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Influx Error",
        "scope": [
            "f2a3b4c5d6e7f8a9"
        ],
        "uncaught": false,
        "x": 1180,
        "y": 520,
        "wires": [
            [
                "af1c01d1e2f3a90c"
            ]
        ]
    },
    {
        "id": "af1c01d1e2f3a90c",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Mark Influx Down",
        "func": "const readiness = global.get('readiness') || {postgres:true,influx:true,amqp:true};\\nreadiness.influx = false;\\nglobal.set('readiness', readiness);\\nmsg.error_category = \"influx\";\\nmsg.error_detail = {message: msg.error && msg.error.message};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 520,
        "wires": [
            [
                "d4e5f6a7b8c9daeb"
            ]
        ]
    },
    {
        "id": "f3a4b5c6d7e8f9a0",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Evaluate Alerts",
        "func": "const p = msg.payload;\\nconst rules = flow.get('alert_rules') || [];\\nconst alerts = [];\\nconst now = Date.now();\\nfor(const rule of rules){\\n    if(!rule.enabled){continue;}\\n    if(rule.metric !== p.metric || (rule.district && rule.district !== p.district) || (rule.site_id && rule.site_id !== p.site_id)){\\n        continue;\\n    }\\n    const windowKey = `rule:${rule.id}`;\\n    const bucket = flow.get(windowKey) || [];\\n    bucket.push({ts: now, value: p.value});\\n    while(bucket.length && (now - bucket[0].ts) > rule.window_s*1000){\\n        bucket.shift();\\n    }\\n    flow.set(windowKey, bucket);\\n    let triggered = false;\\n    if(rule.type === \"threshold\"){\\n        if(rule.comparator === \">\" && p.value > rule.threshold + rule.hysteresis){triggered = true;}\\n        if(rule.comparator === \">=\" && p.value >= rule.threshold + rule.hysteresis){triggered = true;}\\n        if(rule.comparator === \"<\" && p.value < rule.threshold - rule.hysteresis){triggered = true;}\\n    }\\n    if(rule.type === \"rate_of_rise\" && bucket.length >= 2){\\n        const delta = bucket[bucket.length-1].value - bucket[0].value;\\n        const rate = delta / ((bucket[bucket.length-1].ts - bucket[0].ts) / 60000);\\n        if(rate >= rule.rate){triggered = true;}\\n    }\\n    if(triggered){\\n        const last = flow.get(`${windowKey}:last_state`) || {state:\"clear\", ts:0};\\n        if(last.state !== \"alert\" || (now - last.ts) > rule.debounce_s*1000){\\n            alerts.push({rule_id: rule.id, state:\"alert\", reading: p, trace_id: p.trace_id, severity: rule.severity || \"high\"});\\n            flow.set(`${windowKey}:last_state`, {state:\"alert\", ts: now});\\n        }\\n    } else {\\n        const last = flow.get(`${windowKey}:last_state`) || {state:\"clear\", ts:0};\\n        if(last.state !== \"clear\" && Math.abs(p.value - rule.threshold) > rule.hysteresis){\\n            alerts.push({rule_id: rule.id, state:\"clear\", reading: p, trace_id: p.trace_id, severity: \"clear\"});\\n            flow.set(`${windowKey}:last_state`, {state:\"clear\", ts: now});\\n        }\\n    }\\n}\\nif(!alerts.length){return null;}\\nmsg.payload = alerts;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 540,
        "wires": [
            [
                "f4a5b6c7d8e9f0a1"
            ]
        ]
    },
    {
        "id": "f4a5b6c7d8e9f0a1",
        "type": "split",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Split Alerts",
        "splt": "\n",
        "spltType": "str",
        "arraySplt": 1,
        "stream": false,
        "addname": "",
        "x": 1370,
        "y": 540,
        "wires": [
            [
                "f5a6b7c8d9e0f1a2"
            ]
        ]
    },
    {
        "id": "f5a6b7c8d9e0f1a2",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Alert Decorator",
        "func": "const alert = msg.payload;\\nmsg.topic = `alerts.${alert.rule_id}`;\\nmsg.payload = {\\n    ts_iso8601: new Date().toISOString(),\\n    rule_id: alert.rule_id,\\n    state: alert.state,\\n    reading: alert.reading,\\n    severity: alert.severity,\\n    trace_id: alert.trace_id\\n};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 540,
        "wires": [
            [
                "f7a8b9cad0e1f2a4"
            ]
        ]
    },
    {
        "id": "f7a8b9cad0e1f2a4",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Persist Alert State",
        "func": "const store = flow.get('active_alerts') || {};\\nconst payload = msg.payload;\\nif(payload.state === \"alert\"){\\n    store[payload.rule_id] = payload;\\n} else {\\n    delete store[payload.rule_id];\\n}\\nflow.set('active_alerts', store);\\nconst globalAlerts = global.get('active_alerts') || {};\\nif(payload.state === \"alert\"){\\n    globalAlerts[payload.rule_id] = payload;\\n} else {\\n    delete globalAlerts[payload.rule_id];\\n}\\nglobal.set('active_alerts', globalAlerts);\\nconst stats = global.get('stats') || {};\\nstats.alertsActive = Object.keys(globalAlerts).length;\\nglobal.set('stats', stats);\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 540,
        "wires": [
            [
                "f6a7b8c9d0e1f2a3",
                "switch_alert_state"
            ]
        ]
    },
    {
        "id": "switch_alert_state",
        "type": "switch",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Alert State?",
        "property": "payload.state",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "alert",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 2050,
        "y": 540,
        "wires": [
            [
                "f8a9bacbd0e1f2a5"
            ],
            []
        ]
    },
    {
        "id": "f6a7b8c9d0e1f2a3",
        "type": "websocket out",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Alerts WS",
        "server": "cfg_ws_alerts",
        "client": "",
        "x": 2050,
        "y": 500,
        "wires": []
    },
    {
        "id": "f8a9bacbd0e1f2a5",
        "type": "e-mail",
        "z": "d1f2a3b4c5d6e7f8",
        "server": "smtp",
        "port": "587",
        "secure": false,
        "name": "Alert Email",
        "dname": "",
        "x": 2290,
        "y": 540,
        "wires": []
    },
    {
        "id": "fa0bbccd0e1f2a67",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "E2E Latency Tracker",
        "func": "const reading = msg.payload;\\nconst stats = global.get('stats') || {};\\nconst traceId = reading.trace_id;\\nconst startTimes = flow.get('e2e_start') || {};\\nlet latency = null;\\nif(traceId && startTimes[traceId]){\\n    latency = Date.now() - startTimes[traceId];\\n    delete startTimes[traceId];\\n    flow.set('e2e_start', startTimes);\\n    const hist = stats.e2eHistory || [];\\n    hist.push(latency);\\n    while(hist.length > 200){hist.shift();}\\n    const sorted = [...hist].sort((a,b)=>a-b);\\n    const p50 = sorted[Math.floor(sorted.length*0.5)] || 0;\\n    const p95 = sorted[Math.floor(sorted.length*0.95)] || p50;\\n    stats.e2eHistory = hist;\\n    stats.e2e_p50 = p50;\\n    stats.e2e_p95 = p95;\\n}\\nconst consumerLag = Math.max(0, Date.now() - new Date(reading.ts_iso8601).getTime());\\nstats.consumerLagMs = consumerLag;\\nstats.totalConsumed = (stats.totalConsumed || 0) + 1;\\nstats.lastLatencyMs = latency;\\nglobal.set('stats', stats);\\nconst webMsg = {payload: {type: \"telemetry\", reading, latency_ms: latency, consumer_lag_ms: consumerLag}};\\nconst ackMsg = {ack: true, fields: msg.amqp ? msg.amqp.fields : {}};\\nreturn [webMsg, ackMsg];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 620,
        "wires": [
            [
                "f9a0bbccd0e1f2a6"
            ],
            [
                "fb0cbdd0e1f2a678"
            ]
        ]
    },
    {
        "id": "f9a0bbccd0e1f2a6",
        "type": "websocket out",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Telemetry WS",
        "server": "cfg_ws_stream",
        "client": "",
        "x": 1380,
        "y": 620,
        "wires": []
    },
    {
        "id": "fb0cbdd0e1f2a678",
        "type": "amqp ack",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Ack Message",
        "amqp": "cfg_amqp",
        "x": 1390,
        "y": 680,
        "wires": []
    },
    {
        "id": "fd0ebfd0e1f2a89a",
        "type": "inject",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Load Alert Rules",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "[{\"id\":\"level_high\",\"type\":\"threshold\",\"metric\":\"level\",\"district\":\"triana\",\"threshold\":2.3,\"comparator\":\">\",\"window_s\":120,\"debounce_s\":30,\"hysteresis\":0.05,\"enabled\":true,\"severity\":\"critical\"},{\"id\":\"flow_rise\",\"type\":\"rate_of_rise\",\"metric\":\"flow\",\"threshold\":0,\"rate\":15,\"window_s\":300,\"debounce_s\":60,\"hysteresis\":0.1,\"enabled\":true,\"severity\":\"high\"}]",
        "payloadType": "json",
        "x": 160,
        "y": 620,
        "wires": [
            [
                "fc0dbed0e1f2a789"
            ]
        ]
    },
    {
        "id": "fc0dbed0e1f2a789",
        "type": "function",
        "z": "d1f2a3b4c5d6e7f8",
        "name": "Store Alert Rules",
        "func": "flow.set('alert_rules', msg.payload);\\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "aa11bb22cc33dd44",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/metrics",
        "url": "/metrics",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 110,
        "y": 80,
        "wires": [
            [
                "bb22cc33dd44ee55"
            ]
        ]
    },
    {
        "id": "bb22cc33dd44ee55",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Auth Viewer",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst authHeader = msg.req.headers.authorization || \"\";\\nif(!authHeader.startsWith(\"Bearer \")){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"missing bearer token\"};\\n    return [null,msg];\\n}\\nconst token = authHeader.slice(7);\\nconst parts = token.split('.');\\nif(parts.length !== 3){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"invalid token\"};\\n    return [null,msg];\\n}\\nconst secret = process.env.DASHBOARD_SECRET || \"changeme\";\\nconst signature = crypto.createHmac('sha256', secret).update(parts[0]+'.'+parts[1]).digest('base64url');\\nif(signature !== parts[2]){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"signature mismatch\"};\\n    return [null,msg];\\n}\\nconst payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf8'));\\nif(payload.exp && Date.now()/1000 > payload.exp){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"token expired\"};\\n    return [null,msg];\\n}\\nconst hierarchy = {viewer:0, operator:1, admin:2};\\nconst levelUser = hierarchy[payload.role] ?? -1;\\nif(levelUser < hierarchy.viewer){\\n    msg.statusCode = 403;\\n    msg.payload = {error:\"insufficient role\"};\\n    return [null,msg];\\n}\\nmsg.user = payload;\\nreturn [msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 340,
        "y": 80,
        "wires": [
            [
                "cc33dd44ee55ff66"
            ],
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "cc33dd44ee55ff66",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Build Metrics",
        "func": "const stats = global.get('stats') || {};\\nconst activeAlerts = global.get('active_alerts') || {};\\nconst lines = [];\\nlines.push(`# TYPE sewer_ingest_total counter`);\\nlines.push(`sewer_ingest_total ${stats.ingest || 0}`);\\nlines.push(`# TYPE sewer_consumed_total counter`);\\nlines.push(`sewer_consumed_total ${stats.totalConsumed || 0}`);\\nlines.push(`# TYPE sewer_queue_depth gauge`);\\nlines.push(`sewer_queue_depth ${stats.queueDepth || 0}`);\\nlines.push(`# TYPE sewer_consumer_lag_ms gauge`);\\nlines.push(`sewer_consumer_lag_ms ${stats.consumerLagMs || 0}`);\\nlines.push(`# TYPE sewer_e2e_p95_ms gauge`);\\nlines.push(`sewer_e2e_p95_ms ${stats.e2e_p95 || 0}`);\\nlines.push(`# TYPE sewer_e2e_p50_ms gauge`);\\nlines.push(`sewer_e2e_p50_ms ${stats.e2e_p50 || 0}`);\\nlines.push(`# TYPE sewer_active_alerts gauge`);\\nlines.push(`sewer_active_alerts ${Object.keys(activeAlerts).length}`);\\nmsg.payload = lines.join(\"\\n\");\\nmsg.headers = {\"Content-Type\":\"text/plain\"};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 80,
        "wires": [
            [
                "dd44ee55ff667788"
            ]
        ]
    },
    {
        "id": "dd44ee55ff667788",
        "type": "http response",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "HTTP 200",
        "statusCode": "",
        "headers": {},
        "x": 900,
        "y": 200,
        "wires": []
    },
    {
        "id": "ee55ff6677888999",
        "type": "http response",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "HTTP Error",
        "statusCode": "",
        "headers": {},
        "x": 600,
        "y": 160,
        "wires": []
    },
    {
        "id": "ff6677888999aa00",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/healthz",
        "url": "/healthz",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 110,
        "y": 140,
        "wires": [
            [
                "0011223344556677"
            ]
        ]
    },
    {
        "id": "0011223344556677",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Health Check",
        "func": "msg.payload = {status: \"ok\", time: new Date().toISOString()};\\nmsg.statusCode = 200;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 140,
        "wires": [
            [
                "dd44ee55ff667788"
            ]
        ]
    },
    {
        "id": "1122334455667788",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/readyz",
        "url": "/readyz",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 110,
        "y": 200,
        "wires": [
            [
                "2233445566778899"
            ]
        ]
    },
    {
        "id": "2233445566778899",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Readiness Check",
        "func": "const statuses = global.get('readiness') || {postgres:true,influx:true,amqp:true};\\nconst ready = Object.values(statuses).every(Boolean);\\nmsg.statusCode = ready ? 200 : 503;\\nmsg.payload = {ready, components: statuses};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 200,
        "wires": [
            [
                "dd44ee55ff667788"
            ]
        ]
    },
    {
        "id": "33445566778899aa",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/csv/import",
        "url": "/csv/import",
        "method": "post",
        "upload": true,
        "swaggerDoc": "",
        "x": 120,
        "y": 260,
        "wires": [
            [
                "445566778899aabb"
            ]
        ]
    },
    {
        "id": "445566778899aabb",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Auth Operator",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst outputs = [null,null,null];\\nconst authHeader = msg.req.headers.authorization || \"\";\\nif(!authHeader.startsWith(\"Bearer \")){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"missing bearer token\"};\\n    outputs[2] = msg;\\n    return outputs;\\n}\\nconst token = authHeader.slice(7);\\nconst parts = token.split('.');\\nif(parts.length !== 3){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"invalid token\"};\\n    outputs[2] = msg;\\n    return outputs;\\n}\\nconst secret = process.env.DASHBOARD_SECRET || \"changeme\";\\nconst signature = crypto.createHmac('sha256', secret).update(parts[0]+'.'+parts[1]).digest('base64url');\\nif(signature !== parts[2]){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"signature mismatch\"};\\n    outputs[2] = msg;\\n    return outputs;\\n}\\nconst payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf8'));\\nconst hierarchy = {viewer:0, operator:1, admin:2};\\nconst levelUser = hierarchy[payload.role] ?? -1;\\nif(levelUser < hierarchy.operator){\\n    msg.statusCode = 403;\\n    msg.payload = {error:\"insufficient role\"};\\n    outputs[2] = msg;\\n    return outputs;\\n}\\nmsg.user = payload;\\nconst ack = {res: msg.res, payload:{status:\"accepted\"}, statusCode:202};\\ndelete msg.req;\\ndelete msg.res;\\noutputs[0] = msg;\\noutputs[1] = ack;\\nreturn outputs;",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 360,
        "y": 260,
        "wires": [
            [
                "5566778899aabbcc"
            ],
            [
                "dd44ee55ff667788"
            ],
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "5566778899aabbcc",
        "type": "csv",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Parse CSV",
        "sep": ",",
        "hdrin": true,
        "hdrout": false,
        "multi": "one",
        "ret": "\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": false,
        "include_null_values": false,
        "x": 560,
        "y": 240,
        "wires": [
            [
                "66778899aabbccdd"
            ]
        ]
    },
    {
        "id": "66778899aabbccdd",
        "type": "split",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Split Rows",
        "splt": "\n",
        "spltType": "str",
        "arraySplt": 1,
        "stream": false,
        "addname": "",
        "x": 760,
        "y": 240,
        "wires": [
            [
                "778899aabbccddee"
            ]
        ]
    },
    {
        "id": "778899aabbccddee",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "CSV Row \u2192 Msg",
        "func": "const row = msg.payload;\\nmsg.payload = {\\n    ts_iso8601: row.ts_iso8601,\\n    site_id: row.site_id,\\n    district: row.district,\\n    metric: row.metric,\\n    value: Number(row.value),\\n    unit: row.unit,\\n    quality: row.quality || \"imported\",\\n    source: row.source || \"csv\",\\n    reading_id: row.reading_id || null,\\n    trace_id: null,\\n    span_id: null,\\n    schema_ver: \"1.0.0\"\\n};\\nmsg.topic = `sewer.${row.district}.${row.site_id}.${row.metric}`;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 240,
        "wires": [
            [
                "8899aabbccddeeff"
            ]
        ]
    },
    {
        "id": "8899aabbccddeeff",
        "type": "link out",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "CSV\u2192Producer",
        "mode": "link",
        "links": [
            "df1f04d4e5f6a90f"
        ],
        "x": 1180,
        "y": 240,
        "wires": []
    },
    {
        "id": "99aabbccddeeff00",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/csv/export",
        "url": "/csv/export",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 110,
        "y": 320,
        "wires": [
            [
                "aabbccddeeff0011"
            ]
        ]
    },
    {
        "id": "aabbccddeeff0011",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Auth Viewer Export",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst authHeader = msg.req.headers.authorization || \"\";\\nif(!authHeader.startsWith(\"Bearer \")){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"missing bearer token\"};\\n    return [null,msg];\\n}\\nconst token = authHeader.slice(7);\\nconst parts = token.split('.');\\nif(parts.length !== 3){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"invalid token\"};\\n    return [null,msg];\\n}\\nconst secret = process.env.DASHBOARD_SECRET || \"changeme\";\\nconst signature = crypto.createHmac('sha256', secret).update(parts[0]+'.'+parts[1]).digest('base64url');\\nif(signature !== parts[2]){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"signature mismatch\"};\\n    return [null,msg];\\n}\\nconst payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf8'));\\nconst hierarchy = {viewer:0, operator:1, admin:2};\\nconst levelUser = hierarchy[payload.role] ?? -1;\\nif(levelUser < hierarchy.viewer){\\n    msg.statusCode = 403;\\n    msg.payload = {error:\"insufficient role\"};\\n    return [null,msg];\\n}\\nmsg.user = payload;\\nreturn [msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 360,
        "y": 320,
        "wires": [
            [
                "bbccddeeff001122"
            ],
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "bbccddeeff001122",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Build Select",
        "func": "const params = msg.req.query || {};\\nconst district = params.district || null;\\nconst site = params.site_id || null;\\nconst metric = params.metric || null;\\nlet sql = \"SELECT ts_iso8601, site_id, district, metric, value, unit, quality, source, reading_id FROM readings\";\\nconst clauses = [];\\nconst values = [];\\nlet i = 1;\\nif(district){clauses.push(`district=$${i++}`); values.push(district);}\\nif(site){clauses.push(`site_id=$${i++}`); values.push(site);}\\nif(metric){clauses.push(`metric=$${i++}`); values.push(metric);}\\nif(clauses.length){sql += \" WHERE \" + clauses.join(\" AND \" );}\\nsql += \" ORDER BY ts_iso8601 DESC LIMIT 500\";\\nmsg.query = sql;\\nmsg.params = values;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 320,
        "wires": [
            [
                "ccddeeff00112233"
            ]
        ]
    },
    {
        "id": "ccddeeff00112233",
        "type": "postgres",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Postgres Select",
        "postgre": "cfg_postgres",
        "outputs": 1,
        "x": 780,
        "y": 320,
        "wires": [
            [
                "ddeeff0011223344"
            ]
        ]
    },
    {
        "id": "ddeeff0011223344",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Format CSV",
        "func": "const rows = msg.payload || [];\\nconst header = \"ts_iso8601,site_id,district,metric,value,unit,quality,source,reading_id\";\\nconst lines = rows.map(r => [r.ts_iso8601,r.site_id,r.district,r.metric,r.value,r.unit,r.quality,r.source,r.reading_id].join(','));\\nmsg.payload = [header, ...lines].join('\\n');\\nmsg.headers = {\"Content-Type\":\"text/csv\"};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 320,
        "wires": [
            [
                "dd44ee55ff667788"
            ]
        ]
    },
    {
        "id": "eeff001122334455",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/alerts/:id/ack",
        "url": "/alerts/:id/ack",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 380,
        "wires": [
            [
                "ff00112233445566"
            ]
        ]
    },
    {
        "id": "ff00112233445566",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Auth Operator Ack",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst authHeader = msg.req.headers.authorization || \"\";\\nif(!authHeader.startsWith(\"Bearer \")){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"missing bearer token\"};\\n    return [null,msg];\\n}\\nconst token = authHeader.slice(7);\\nconst parts = token.split('.');\\nif(parts.length !== 3){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"invalid token\"};\\n    return [null,msg];\\n}\\nconst secret = process.env.DASHBOARD_SECRET || \"changeme\";\\nconst signature = crypto.createHmac('sha256', secret).update(parts[0]+'.'+parts[1]).digest('base64url');\\nif(signature !== parts[2]){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"signature mismatch\"};\\n    return [null,msg];\\n}\\nconst payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf8'));\\nconst hierarchy = {viewer:0, operator:1, admin:2};\\nconst levelUser = hierarchy[payload.role] ?? -1;\\nif(levelUser < hierarchy.operator){\\n    msg.statusCode = 403;\\n    msg.payload = {error:\"insufficient role\"};\\n    return [null,msg];\\n}\\nmsg.user = payload;\\nreturn [msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 360,
        "y": 380,
        "wires": [
            [
                "0011223344556678"
            ],
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "0011223344556678",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Ack Alert",
        "func": "const alertId = msg.req.params.id;\\nconst actor = msg.user && msg.user.sub ? msg.user.sub : \"unknown\";\\nconst store = global.get('active_alerts') || {};\\nconst alert = store[alertId];\\nif(!alert){\\n    msg.statusCode = 404;\\n    msg.payload = {error:\"alert not found\"};\\n    return msg;\\n}\\nalert.ack = {\\n    by: actor,\\n    ts_iso8601: new Date().toISOString(),\\n    via: \"ui\"\\n};\\nstore[alertId] = alert;\\nglobal.set('active_alerts', store);\\nmsg.statusCode = 200;\\nmsg.payload = alert;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "dd44ee55ff667788",
                "f6a7b8c9d0e1f2a3"
            ]
        ]
    },
    {
        "id": "1122334455667789",
        "type": "cronplus",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Rollup Scheduler",
        "outputField": "payload",
        "timeZone": "Europe/Madrid",
        "outputs": 1,
        "options": [
            {
                "name": "minute",
                "topic": "rollup_minute",
                "payloadType": "default",
                "payload": "",
                "type": "default",
                "expression": "0 */1 * * * *",
                "location": "",
                "offset": "0",
                "solarType": "all",
                "solarEvents": "sunrise"
            }
        ],
        "x": 130,
        "y": 460,
        "wires": [
            [
                "223344556677889a"
            ]
        ]
    },
    {
        "id": "223344556677889a",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Prepare Rollup Queries",
        "func": "msg.query = `from(bucket:\"sewer\") |> range(start: -1h) |> filter(fn: (r) => r._measurement == \"reading\") |> aggregateWindow(every: 1m, fn: mean, createEmpty: false)`;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 460,
        "wires": [
            [
                "33445566778899ab"
            ]
        ]
    },
    {
        "id": "33445566778899ab",
        "type": "influxdb in",
        "z": "e1f2a3b4c5d6e7f9",
        "influxdb": "cfg_influx",
        "name": "Influx Rollup",
        "query": "",
        "rawOutput": true,
        "precision": "",
        "retentionPolicy": "",
        "org": "",
        "x": 600,
        "y": 460,
        "wires": [
            [
                "445566778899aabc"
            ]
        ]
    },
    {
        "id": "445566778899aabc",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Store Rollups",
        "func": "const data = msg.payload;\\nglobal.set('rollups', data);\\nmsg.payload = {type:\"rollup\", data};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 460,
        "wires": [
            [
                "f9a0bbccd0e1f2a6"
            ]
        ]
    },
    {
        "id": "5566778899aabccd",
        "type": "http in",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "/backups/run",
        "url": "/backups/run",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 120,
        "y": 520,
        "wires": [
            [
                "66778899aabbcdef"
            ]
        ]
    },
    {
        "id": "66778899aabbcdef",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Auth Admin",
        "func": "const crypto = global.get('crypto') || require('crypto');\\nconst authHeader = msg.req.headers.authorization || \"\";\\nif(!authHeader.startsWith(\"Bearer \")){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"missing bearer token\"};\\n    return [null,msg];\\n}\\nconst token = authHeader.slice(7);\\nconst parts = token.split('.');\\nif(parts.length !== 3){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"invalid token\"};\\n    return [null,msg];\\n}\\nconst secret = process.env.DASHBOARD_SECRET || \"changeme\";\\nconst signature = crypto.createHmac('sha256', secret).update(parts[0]+'.'+parts[1]).digest('base64url');\\nif(signature !== parts[2]){\\n    msg.statusCode = 401;\\n    msg.payload = {error:\"signature mismatch\"};\\n    return [null,msg];\\n}\\nconst payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf8'));\\nconst hierarchy = {viewer:0, operator:1, admin:2};\\nconst levelUser = hierarchy[payload.role] ?? -1;\\nif(levelUser < hierarchy.admin){\\n    msg.statusCode = 403;\\n    msg.payload = {error:\"insufficient role\"};\\n    return [null,msg];\\n}\\nmsg.user = payload;\\nreturn [msg,null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 360,
        "y": 520,
        "wires": [
            [
                "778899aabbcdef01"
            ],
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "778899aabbcdef01",
        "type": "exec",
        "z": "e1f2a3b4c5d6e7f9",
        "command": "pg_dump --dbname=${PG_URL} --file=/data/backups/telemetry.sql",
        "addpay": false,
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "oldrc": false,
        "name": "Run Backup",
        "x": 590,
        "y": 520,
        "wires": [
            [
                "8899aabbcdef0123"
            ],
            [
                "99aabbcdef012345"
            ],
            [
                "99aabbcdef012345"
            ]
        ]
    },
    {
        "id": "8899aabbcdef0123",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Backup Response",
        "func": "msg.payload = {status:\"backup_started\", detail: msg.payload};\\nmsg.statusCode = 202;\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 500,
        "wires": [
            [
                "dd44ee55ff667788"
            ]
        ]
    },
    {
        "id": "99aabbcdef012345",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Backup Error",
        "func": "msg.statusCode = 500;\\nmsg.payload = {error:\"backup_failed\", detail: msg.payload};\\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 560,
        "wires": [
            [
                "ee55ff6677888999"
            ]
        ]
    },
    {
        "id": "bbccdef012345678",
        "type": "inject",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Init Readiness",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "once": true,
        "onceDelay": 0.5,
        "topic": "",
        "payload": "{\"postgres\":false,\"influx\":false,\"amqp\":false}",
        "payloadType": "json",
        "x": 130,
        "y": 20,
        "wires": [
            [
                "aabbcdef01234567"
            ]
        ]
    },
    {
        "id": "aabbcdef01234567",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Set Initial Readiness",
        "func": "global.set('readiness', msg.payload);\\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "ccdef0123456789a",
        "type": "inject",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Init Stats",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "once": true,
        "onceDelay": 0.6,
        "topic": "",
        "payload": "{}",
        "payloadType": "json",
        "x": 120,
        "y": 560,
        "wires": [
            [
                "ddef0123456789ab"
            ]
        ]
    },
    {
        "id": "ddef0123456789ab",
        "type": "function",
        "z": "e1f2a3b4c5d6e7f9",
        "name": "Set Initial Stats",
        "func": "global.set('stats', {ingest:0,totalConsumed:0,queueDepth:0,e2eHistory:[],e2e_p50:0,e2e_p95:0});\\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "cfg_mqtt",
        "type": "mqtt-broker",
        "name": "MQTT Broker",
        "broker": "mqtt",
        "port": "1883",
        "clientid": "",
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": false,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "credentials": {}
    },
    {
        "id": "cfg_amqp",
        "type": "amqp",
        "hostname": "rabbitmq",
        "port": "5672",
        "vhost": "/",
        "name": "RabbitMQ",
        "usetls": false,
        "protocol": "amqp",
        "username": "sewer",
        "password": "sewer"
    },
    {
        "id": "cfg_influx",
        "type": "influxdb",
        "hostname": "influxdb",
        "port": "8086",
        "protocol": "http",
        "database": "sewer",
        "name": "InfluxDB",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "",
        "secure": false,
        "rejectUnauthorized": false,
        "token": "${INFLUX_TOKEN}",
        "organization": "sewer",
        "bucket": "sewer"
    },
    {
        "id": "cfg_postgres",
        "type": "postgresdb",
        "hostname": "postgres",
        "port": "5432",
        "db": "sewer",
        "ssl": false,
        "name": "Timescale",
        "alias": "",
        "user": "sewer",
        "password": "${PG_PASSWORD}"
    },
    {
        "id": "cfg_ws_stream",
        "type": "websocket-listener",
        "path": "/ws/telemetry",
        "wholemsg": "true"
    },
    {
        "id": "cfg_ws_alerts",
        "type": "websocket-listener",
        "path": "/ws/alerts",
        "wholemsg": "true"
    }
]
